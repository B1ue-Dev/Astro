{"Documentation website": "Over the spanning history of our library, our documentation website link has changed numerous times. The official and final route is https://interactionspy.rtfd.io/, but the following will also work:\n\nhttps://discord-py-slash-command.rtfd.io/\nhttps://discord-interactions.rtfd.io/", "Installing the unstable branch": "This is how to uninstall `stable` and install the `unstable` branch:\n\n```\npip uninstall discord-py-interactions\npip install -U git+https://github.com/interactions-py/library@unstable\n```", "Creating a basic slash command": "Creating slash commands have never been easier. This is how you do it:\n\n```py\nimport interactions\n\nbot = interactions.Client(token=\"...\")\n\n@bot.command(\n    name=\"my_new_command\",\n    description=\"Test description!\",\n    scope=guild_id,\n)\nasync def my_command(ctx: interactions.CommandContext):\n    await ctx.send(\"Hi there!\")\n```\n\n\nThere are a few things you should consider when doing this, though:\n- a command name must be lowercase and can only contain `-`/`_` as special symbols, no spaces\n- if you do not specify a scope, (the `scope` kwarg) the command will be registered as a global one and take up to one hour to sync. See `global versus guild commands` to learn more.", "Adding options to slash commands": "Sometimes, you might want to have \"options,\" otherwise known as arguments to your slash commands. This is how you do that:\n\n```py\nimport interactions\n\nbot = interactions.Client(token=\"...\")\n\n@bot.command(\n    name=\"another_command\", \n    description=\"Test description!\", \n    scope=guild_id,\n    options= [\n        interactions.Option(\n            name=\"choose_wisely\",\n            description=\"A descriptive description\",\n            type=interactions.OptionType.STRING,\n            required=True,\n            choices=[\n                interactions.Choice(name=\"Death\", value=\"death\"), interactions.Choice(name=\"run\", value=\"run\"), \n            ], \n        ),\n    ],\n)\nasync def cmd(ctx: interactions.CommandContext, choose_wisely: str):\n    if choose_wisely == \"run\":\n        await ctx.send(f\"{ctx.author.mention} runs away!\") \n    elif choose_wisely == \"death\":\n        await ctx.send(f\"So... You've chosen death, <@{ctx.author.mention}>?\")\n```", "Adding choices to slash command options": "While having options in a slash command can be crucial, sometimes you might want to force the user to select from a list of pre-defined values, which we call \"choices.\" This is how you would do that:\n\n```py\nimport interactions\n\nbot = interactions.Client(token=\"...\")\n\n@bot.command(\n    name=\"another_command\", \n    description=\"Test description!\", \n    scope=guild_id,\n    options= [\n        interactions.Option(\n            name=\"choose_wisely\",\n            description=\"A descriptive description\",\n            type=interactions.OptionType.STRING,\n            required=True,\n            choices=[\n                interactions.Choice(name=\"Death\", value=\"death\"), interactions.Choice(name=\"run\", value=\"run\"), \n            ], \n        ),\n    ],\n)\nasync def cmd(ctx: interactions.CommandContext, choose_wisely: str):\n    if choose_wisely == \"run\":\n        await ctx.send(f\"{ctx.author.mention} runs away!\") \n    elif choose_wisely == \"death\":\n        await ctx.send(f\"So... You've chosen death, <@{ctx.author.mention}>?\")\n```", "Nesting slash commands within themselves": "Keeping track of a lot of slash commands is hard. And, more importantly, you might want to organize them in a particular manner. Introducing: subcommands. This essentially nests a command as an option of variation within itself, allowing for building a standalone \"substructure\" of the command, or a \"group\" of said substructure. This is how:\n\n```py\nimport interactions\n\nbot = interactions.Client(token=\"...\")\n\n@bot.command(\n    name=\"base_command\", \n    description=\"This description isn't seen in UI (yet?)\", \n    scope=guild_id,\n    options= [\n        interactions.Option(\n            name=\"command_name\",\n            description=\"A descriptive description\",\n            type=interactions.OptionType.SUB_COMMAND\n            options=[\n                interactions.Option(\n                    name=\"option\",\n                    description=\"A descriptive description\",\n                    type=interactions.OptionType.thetypeyouwant,\n                    required=False,\n                ),\n        interactions.Option(\n            name=\"second_command\",\n            description=\"A descriptive description\",\n            type=interactions.OptionType.SUB_COMMAND\n            options=[\n                interactions.Option(\n                    name=\"second_option\",\n                    description=\"A descriptive description\",\n                    type=interactions.OptionType.thetypeyouwant,\n                    required=False,\n                ),\n            ],\n        ),\n    ],\n)\nasync def cmd(ctx: interactions.CommandContext, sub_command: str, option=None, second_option=None):\n    if sub_command == \"command_name\":\n      await ctx.send(f\"You selected the command_name sub command and put in {option}\")\n    elif sub_command == \"second_command\":\n      await ctx.send(f\"You selected the second_command sub command and put in {second_option}\")\u200a\n```", "Pinging staff": "Please do not ping staff (anyone who are above the Booster role) for support matters. These are people who are volunteering their time towards guiding users in using this library. ||Plus, nobody enjoys getting randomly pinged out of nowhere for something.||\n\nIf you're in a dire need of help, we kindly ask for you to be patient. No matter how big or small the issue at hand is, we assure you that it can wait. __Excessive pinging or the continuation of such may result in a punishment__ handed out at the discretion of the moderation team.", "Adding extensions, aka. \"cogs\"": "Adding an extension into your bot's codebase is really easy, and can be done as such:\n\n**main.py**\n```py\nimport interactions\n\nclient = interactions.Client(token=\"...\")\nclient.load(\"path.to.file\")\nclient.start()\n```\n\n**path/to/file.py**\n```py\nimport interactions\n\nclass MyExtension(interactions.Extension):\n    def __init__(self, bot):\n        self.bot: interactions.Client = bot\n\ndef setup(bot):\n    MyExtension(bot)\n```", "Interaction limits": "There are numerous limits that apply towards interactions:\n\n**Application Command Existence**\n- They must match the `^[\\w-]{1,32}$` regex.\n> The regex should ideally be `^[a-z0-9_-]{1,32}$`, as the above regex does not consider for message or user commands and *only* values chat-input-based ones.\n> \n> A chat-input command cannot have spaces, but user and message commands can.\n- You can only have up to 100 **top-level** global commands.\n> A top-level command is the base of the command if you're using subcommands. If not, all you need to know is that you can have up to 100 global commands regardless of name.\n> \n> A subcommand group can only have up to 25 subcommands, as well as up to 25 subcommands in total per group.\n- You can only have up to 100 guild-unique commands per guild.\n- Actions on an application are:\n> Limited in bulk by 2 per 60 seconds.\n> Limited in creation by 3 per second, per 100 *global* per day.\n\n**Application Command Structure**\n- You can only have up to 25 options.\n> An option may also have only up to 25 choices presented.\n> \n> If your option is autocompleted, you cannot present choices at all.\n> Additionally, an autocompletion option can only present up to 25 choices.\n- The base character limit is __4000__.\n> This applies to every `name`, `description` and `value` field present.\n\n**Component Structure**\n- You can only have up to 25 characters per `label` field.\n> If your component is a button, then the character limit is specifically __80__.\n- You can only have up to 100 characters per `value` field.\n- You can only have up to 50 characters per `description` field.\n- You can only have up to 100 characters per `custom_id` field.", "Using and listening for events": "interactions.py aims to be a library that strictly follows the API's schema. Because of such, we've adopted a constant form for how events are dispatched for being able to be listened to, and their data models:\n\n- We follow PascalCase for the object of an event, for pythonic reasons.\n- When listening for an event, it will always be lowercased and prefixed with on following underscores per resource aspect respectively.\nFor example, `MESSAGE_CREATE` is the official name of a message creation event being dispatched. In order to listen to this, use `on_message_create`.\n\nWhen using a data model, you will always drop the first and last part of the event name/path, for example:\n`VOICE_STATE_UPDATE` -> `interactions.VoiceState`\n\nWhen listening to an event, you will use either:\n\n```py\nimport interactions\n\nclient = interactions.Client(token=\"...\")\n\n# Method 1\n@client.event(\"message_create\")\nasync def on_message(message: interactions.Message):\n    ...\n\n# Method 2\n@client.event\nasync def on_message_create(message: interactions.Message):\n    ...\n```\n\nIn order to view the full list of events the Discord API dispatch, please refer to the developer documentation portal.\nhttps://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-events\n", "Global versus guild commands": "There is a distinct difference between application commands: one can be global, meaning that they sho up in every guild the bot is in, and then guild: they only show up in that guild; no others.\n\nGlobal commands take up to 1 hour for registration into the API registrar. If you can't see your command, chances are, you've accidentally declared it as a global one. It is recommended as a development practice to create your commands to be guild-specific first before finalising their design, as guild commands update *instantaneously*. This is how you do that:\n\n```py\nimport interactions\n\nbot = interactions.Client(token=\"...\")\n\n@bot.command(\n    ..., # everything else you have so far\n    scope=guild_id_here\n)\n```\n\n`guild_id_here` represents either an `interactions.Guild`, `interactions.Snowflake` or `int`. Additionally, the `scope` kwarg here can be a list, meaning you can register the same commands under numerous guilds.", "Missing access": "Sometimes, the API will provide you with the error code `50001`, otherwise known as `Missing Access`. There are a few reasons why this may happen, but the most commonly reason why this occurs is due to the bot being invited properly. In order to mitigate this error from becoming common, make sure to do the following whenever inviting a bot for commands or components:\n\n- If the bot is already in your guild, kick it.\n- In the developer OAuth portal, **make sure `applications.commands` is selected as a scope** when inviting. It must be selected *with* the `bot` scope.\n- Re-invite the bot.", "Running interactions.py with another library": "Some bot developers may find themselves in a position where they have either a large codebase, little time to migrate, the lack of something presented in this library, or possibly the combination of all 3 in order to effectively use only our library. Because of this, we try to make our library easy to work with other event loops. Natively, our library only expects 1 event loop of its own, as we don't support IPC-alike pipes. However, you're able to work around this by doing the following:\n\n```py\nimport asyncio\nimport discord\nimport interactions\n\n# Keep your instances separate.\nbot1 = discord.ext.commands.Bot(prefix=\"/\")\nbot2 = interactions.Client(token=\"...\")\n\n# Create a loop attr, and make tasks of the bots under it.\nloop = asyncio.get_event_loop()\ntask1 = loop.create_task(bot1.start(token=\"...\", bot=True))\ntask2 = loop.create_task(bot2._ready())\n\n# Now we have to gather the tasks together, and execute them under the same loop\ngathered = asyncio.gather(task1, task2, loop=loop)\nloop.run_until_complete(gathered)\n```", "Interaction ratelimits": "Separate to `Interaction limits`, this is more geared towards the *rate* of interactions being applied actions to, with more outline towards their implementation.\n\n**REST**/Web API:\n```\n        POST Message |  5/5s    | per-channel\n      DELETE Message |  5/1s    | per-channel\n PUT/DELETE Reaction |  1/0.25s | per-channel\n       PATCH Channel |  2/600s  | per-channel\n        PATCH Member |  10/10s  | per-guild\n   PATCH Member Nick |  1/1s    | per-guild\n      PATCH Username |  2/3600s | per-account\n      |All Requests| |  50/1s   | per-account\n```\n\n**Gateway**:\n```\n     Gateway Connect |   1/5s   | per-account\n     Presence Update |   5/60s  | per-session\n |All Sent Messages| | 120/60s  | per-session\n```", "\"Attribute X is missing from Y, skipping...\"": "This is a warning that can only be shown when the logger is set to be visible. When this is the case, the warning exists to tell developers that an attribute is missing from one of our data models, and that it won't be added, otherwise \"skipped\" during our serialization process.\n\n*You do not need to worry about this at all if you're not trying to use the missing attribute.* If you get this, please give us a ping in #unstable about it, or check out the GitHub repository to see if it's being planned or has been implemented!", "Issues with 3rd party libraries": "We understand that not everything bot developers may possibly want get included in the \"core\" library, aka. the library itself, interactions.py. However, sometimes there may be bugs or otherwise unintended effects that come from the result of 3rd party libraries being used.\n\nIn any case where you are getting an issue with using our library, please refrain from making a post in #help when one of the following or multiple apply:\n\n- You're using a pre-release or the `unstable` branch.\n- The 3rd party library in question bases off of our development branch or pre-releases.\n> This also includes if it is outdated or lacks stable updates/chores.\n\nIf you absolutely must, please post in #external **if it's a 3rd party for our library** and otherwise in the support server of the library it is geared towards, e.g. Pycord. We will only recognize posts in the #unstable if the issue is otherwise caused by something that the library terminates a bot connection over.", "Creating a basic context menu command": "Context menu commands are a rather verbose way of saying message or user-based commands. These commands are shown in the \"contextual\" menu when right clicking on a user or a message. There are 2 ways you can go about creating these commands:\n\n- Using a feature converter, e.g. `@user_command` or `@message_command`.\n- Using the `type` kwarg in `@command`.\n\nIf you use the latter, please make sure to specify the value as a representation of `interactions.ApplicationCommandType`.", "discord-components": "As of version 4.0 of this library, the formerly renounced project maintainer of **discord-components**, kiki, have announced their intent into migrating with ours. We've successfully achieved in bringing feature parity of their library over to ours in having an object orientation paradigm approach, as well as grossly simplified decorator usage.\n\nAs a result of this, the former library will no longer be supported as a standalone. You *must* migrate over to this library to continue using the features that it originally once had.", "Version EOL and EOS": "EOL and EOS stand for End of Life and End of Service respectively. These are terms we use when we officially acknowledge a version as being deprecated. Here's what you can expect from hearing one of these:\n\n**End of Life**\nWhen a version gets labeled as this, it means that it's served all of its purpose in a useful manner. The version can still be used, but it lacks value in contrast to newer versions. It's simply a way to say \"this is now deprecated. Please move over, but you don't have to.\"\n\n**End of Service**\nThis means that the version is being nailed in a coffin. The version will no longer work after the given date, regardless of changing factors forcing this such as the Discord API version. An example of this are versions 3.0 and below of interactions.py, which will be labeled as EOS when the message continent privileged intent becomes effective. This is due to the Discord API moving version 6 from deprecated status to decommissioned, essentially \"killing\" the ability to use these versions.", "The application did not respond": "", "Adding components to an interaction": "Commands may be the cr\u00e8me de la cr\u00e8me of our library, but we also specialize in allowing developers to use *components,* extendable parts of interactions in their bots. These components can be attached onto a message, which can run either indefinitely or with a set time expiration for separate actions.\n\nIn order to send components, you must use an official component. So far, they are `Button` and `SelectMenu`. See `Sending buttons as components` and `Sending selection menus as components` for more.", "Sending buttons as components": "Buttons are a simple yet powerful way to enable bot developers and users to run actions without constantly typing out a command. This is how you create a button to send, as well as parse:\n\n```py\nimport interactions\n\nbot = interactions.Client(token=\"...\")\n\n@bot.command(...)\nasync def command(ctx):\n    button = interactions.Button(\n        style=interactions.ButtonStyle.PRIMARY,\n        label=\"Click me please!\",\n        custom_id=\"listen_to_this\"\n    )\n    await ctx.send(components=button)\n\n@bot.component(\"listen_to_this\")\nasync def button_response(ctx):\n    await ctx.send(\"I got clicked!\")\n```", "Sending selection menus as components": "Select menus allow you to bring the concept of choices in commands, but to the message playing field. Not only are they pre-defined, but you may also select more than 1 choice in the same component. This is how it's all done:\n\n```py\nimport interactions\n\nbot = interactions.Client(token=\"...\")\n\n@bot.command(...)\nasync def command(ctx):\n    menu = interactions.SelectMenu(\n        options=[interactions.SelectOption(name=\"me\", value=\"no\")],\n        label=\"Check out my suite\",\n        custom_id=\"listen_to_this\",\n        min_values=1,\n        max_values=3\n    )\n    await ctx.send(components=menu)\n\n@bot.component(\"listen_to_this\")\nasync def menu_response(ctx, val):\n    await ctx.send(f\"You chose {val[0]}.\")\n```", "\"I need a tool to do X\"": "There's a high chance of probability that the tool you're looking for has already been developed and made ready for public use by an external developer. In order to find out whether this is the case or not, please check our GitHub organization for a repository achieving what you're in need of.\nhttps://github.com/interactions-py", "Using the right channels": "Please use the right channel. We try to take things serious when it comes to library development. Here's a rough guide towards knowing where you need to go:\n\n- If it's about coding a new feature, please use #unstable or #external. (if it's a 3rd party)\n- If you're trying to report a bug, please use:\n> #unstable for bugs on the `unstable` branch, from a pre-release or beta version\n> #stable for bugs on the `stable` branch\n> #help for anything else\n\nThese channels are very important for us so that we are able to properly organize and collect all discussions in the right place at the right time. The channels under the chatting category should not be misused, as we frown upon things such as asking for help in #general. See `Ask for help in #help` for more.", "Ask for help in #help": "**Please use the #help channel for asking for help!** It doesn't matter what size it is, how problematic it is, or whether it's worthy of creating a thread over: any and all questions related to getting support must go in here. We will not answer questions or give replies to people who ask for help outside of this channel. ", "Using versions 3.0 and below": "Versions 3.0 and below have been officially labeled as EOL, and will effectively be EOS starting __30 April 2022__. See `Version EOL and EOS` for more."}